# Visão Geral
Apesar de algumas dificuldades encontradas no processo de desenvolvimento, afirmo que as soluções por mim elaboradas e aqui armazenadas providenciaram uma experiência positiva para mim. Em específico, estes foram os projetos que mais me exigiram a procura de recursos e auxílio exteriores por incluírem conceitos (e posteriormente, a aplicação destes) não familiares a mim.  
Os arquivos de cada desafio possuem alguns comentários, em inglês, que explicam a funcionalidade e raciocínio por trás de algumas linhas de código. Dito isso, detalharei agora as nuâncias dos desafios solucionados.
## Loja de Jogos do Seu Manoel
Dentre os dois desafios, creio que este foi o mais complexo de resolver. Contudo, alguns aspectos como a manipulação de dados em arquivos JSON já eram conhecidos por mim, logo penso que houve certo equilíbrio na hora de desenvolver o algoritmo requisitado. Logo de início, surgiu-me um questionamento; ***Como que o algoritmo identificaria se o arquivo JSON enviado pelo usuário contêm os campos necessarios para o seu funcionamento?*** Estava dentro do possível eu criar checagens que permitissem ou não que o processamento do arquivo ocorresse dependendo da presença de campos como o ID de pedidos, caixas, etc.  
Porém, julguei mais necessário focar apenas na funcionalidade do que me foi pedido no desafio, ao invés de elaborar soluções para *Edge Cases*. Então, o algoritmo funciona na presunção de que o usuário seguirá o modelo-exemplo enviado a mim e disponível na pasta do Desafio 1.  
Certamente, a parte da organização dos produtos na caixa foi o aspecto mais dificultoso deste desafio. Recorri a especialistas, fórums e artigos online nas esperanças de achar exemplos de desafios similares a este, com linhas de raciocínio que permitissem que eu desenvolvesse alguma resolução funcional. De fato, encontrei conceitos e ideias para soluções que satisfaziam o enunciado, como por exemplo a criação de um sistema de *grid* (Pense no jogo *Tetris*) que checasse, centímetro por centímetro, todas as posições possíveis dentro da caixa a fim de otimizar a alocação de produtos dentro desta. Porém, julguei estas como não-viáveis para este desafio, apesar do seu alto nível de precisão. Isto se dá pela complexidade de tal sistema e pelo tempo limite do teste, bem como minha inexperiência no desenvolvimento de qualquer programa com um cálculo/funcionamento igual ou parecido.  
Portanto, decidi que para checar se os produtos cabem dentro de dada caixa o programa faria uso de uma função que recebe os parâmetros *box* e *item*. Primeiro, ele checa se as dimensões (altura, largura e comprimento) do produto cabem dentro da caixa, verificando se são menores ou iguais aos valores correspondentes da caixa. Inicialmente, esta era a única checagem que o programa fazia, porém desenvolvi o pensamento de que os itens poderiam ser **rotacionados** para que coubessem em uma caixa (À primeira vista, um item 50x40x30 não caberia em uma caixa 30x40x50[...]). Logo, a função "rotaciona" os items para que fiquem **de costas e de lado** durante a checagem ([...] porém poderíamos virar o produto **de costas** para que ele ocupasse um espaço 30x40x50, cabendo na caixa). Adicionalmente, o programa verifica se o volume do item é menor ou igual o volume da caixa. Se ambas as verificações forem verdadeiras, o item é posto dentro da caixa e tem o seu valor de volume **subtraído** do volume da caixa. 
Creio que este algoritmo se aproxime de uma solução satisfatória, porém ele certamente carece da maior precisão ofertada pelo sistema de *grid* previamente mencionado. Vale notar que esse processo, da maneira que foi aplicado, prioriza colocar ***os maiores itens na menor caixa possível***, logo caso um pedido tenha vários itens que pudessem caber em uma única caixa maior que a menor caixa disponível, o programa não checará esta possibilidade, o que pode aumentar o número de caixas usadas.
A maneira que o usuário obtêm o arquivo de saída é por meio do envio do JSON a ser lido pelo algoritmo. Após o algoritmo percorrer este arquivo, ele fará o *download* automático do JSON a ser retornado.
## Escola do Professor Girafales
Este foi o desafio mais fácil, ao meu ver. Eu já era familiarizado com modelos ER, bem como a estrutuação de bancos de dados e SQL. Creio que este desafio era muito mais **objetivo** que o primeiro, não havendo possibilidade de interpretações diferentes dos problemas apresentados. As tabelas contêm todas as colunas apresentadas no modelo ER como requisitado. No modelo, as colunas **vermelhas** indicam *PRIMARY KEY*s, as **verdes** indicam *FOREIGN KEY*s e as **azuis** indicam *FOREIGN KEY*s que fazem parte da *PRIMARY KEY* composta de dada tabela.  
Para os *queries* requisitados, decidi desenvolver uma página estática com PHP que, por meio de outro arquivo PHP, se conecta com o banco de dados local da máquina, que fora elaborado com MySQL. Após isso, o programa faz o *query* do total de horários para cada professor, junto dos *queries* para mostrar as salas em uso e desocupadas.  
A maior dificuldade para este desafio foi re-aprender a sintaxe do MySQL (*SELECT[...]* em específico), porém após ver exemplos *online* e documentação vi que ele disponibilizava as ferramentas necessárias para procurar exatamente o que o desafio requisitava.  
Vale notar que o programa procura, no arquivo *db.php*, pelo servidor *localhost* no porte *3307*, banco de dados *escolagirafales* e pelo usuário *root*, com este não tendo senha. Ajustes podem ser necessários neste campos do arquivo para o funcionamento dele.
### Nota: Na pasta do Desafio 2 há os arquivos *.sql* oriundos dos *dumps*; Um para a estrutura do banco de dados e outro para os dados em si. Não está incluso o comando para criar o banco de dados "escolagirafales".
